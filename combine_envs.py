from __future__ import annotations

import argparse
from collections import OrderedDict
from pathlib import Path
from typing import Dict, Iterable, List, Tuple


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Merge multiple .env files, highlighting similarities and differences, "
            "and produce a single combined output."
        )
    )
    parser.add_argument(
        "env_files",
        nargs="+",
        type=Path,
        help="Paths to the source .env files (e.g., dev.env staging.env prod.env).",
    )
    parser.add_argument(
        "--names",
        nargs="*",
        help=(
            "Optional display names for each environment, in the same order as env_files. "
            "Defaults to the stem of each file path."
        ),
    )
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        default=Path("combined.env"),
        help="Path for the generated combined .env file.",
    )
    return parser.parse_args()


def load_env(path: Path) -> OrderedDict[str, str]:
    pairs: OrderedDict[str, str] = OrderedDict()
    with path.open() as handle:
        for raw_line in handle:
            line = raw_line.strip()
            if not line or line.startswith("#"):
                continue
            if "=" not in line:
                continue
            key, value = line.split("=", 1)
            pairs[key.strip()] = value.strip()
    return pairs


def gather_keys(env_maps: Iterable[Dict[str, str]]) -> List[str]:
    keys: List[str] = []
    seen = set()
    for env_map in env_maps:
        for key in env_map:
            if key not in seen:
                keys.append(key)
                seen.add(key)
    return keys


def write_combined_env(
    keys: List[str],
    env_maps: List[Dict[str, str]],
    env_names: List[str],
    env_paths: List[Path],
    output_path: Path,
) -> Tuple[int, int]:
    common_count = 0
    differing_count = 0
    lines: List[str] = []

    sources = ", ".join(f"{name}={path}" for name, path in zip(env_names, env_paths))
    lines.append("# Combined environment generated by combine_envs.py")
    lines.append(f"# Sources: {sources}")
    lines.append("# Common values appear once; differing values include notes per environment.")
    lines.append("")
    lines.append("# Common values")

    for key in keys:
        values = [env_map.get(key) for env_map in env_maps]
        non_null_values = [value for value in values if value is not None]
        is_common = len(non_null_values) == len(env_maps) and all(
            value == non_null_values[0] for value in non_null_values
        )

        if is_common:
            common_count += 1
            lines.append(f"{key}={non_null_values[0]}")
            continue

        differing_count += 1
        descriptor = ", ".join(
            f"{name}={value if value is not None else '<missing>'}"
            for name, value in zip(env_names, values)
        )
        default_value = non_null_values[0] if non_null_values else ""
        lines.append("")
        lines.append(f"# {key} varies: {descriptor}")
        lines.append(f"{key}={default_value}")

    content = "\n".join(lines) + "\n"
    output_path.write_text(content)
    return common_count, differing_count


if __name__ == "__main__":
    args = parse_args()
    if len(args.env_files) < 2:
        raise SystemExit("Provide at least two .env files to merge.")

    if args.names and len(args.names) != len(args.env_files):
        raise SystemExit("The number of names must match the number of env_files.")

    env_files = [path for path in args.env_files]
    env_names = args.names or [path.stem for path in env_files]

    env_maps = [load_env(path) for path in env_files]
    keys = gather_keys(env_maps)
    common_count, differing_count = write_combined_env(
        keys, env_maps, env_names, env_files, args.output
    )

    print(
        "Combined %d environment files into %s (%d common, %d differing keys)."
        % (len(env_files), args.output, common_count, differing_count)
    )
